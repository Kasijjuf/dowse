#!/usr/bin/env zsh

# sql functions

# creates a database for the current network
# uses an unique hash to the network location
sql_create_database() {
	fn sql_create_database $*
	name="$1"
	req=(name)
	ckreq || return $?
	act " Create database if not exists ..."
        print "CREATE DATABASE IF NOT EXISTS $db[$name];" | $sql 2>/dev/null
	# TODO: better check of error code if needed	
}

# Set the root password 
sql_set_root_password() {
	fn sql_set_root_password $*
	password="$1"
	setted_up="$2"
	req=(password setted_up sql_wp)
	ckreq || return $?
	act " Set the root password "
	
	[[ -r "$setted_up" ]] || {
            print "update mysql.user set password=password('"$password"') where user = 'root';flush privileges;" | $sql_wp 2>/dev/null
	    touch $setted_up ;
	}
	# TODO: better check of error code if needed	
}


# Integrate with Redis creating the function and trigger to ...
sql_integrate_with_redis() {
	fn sql_integrate_with_redis $*
	setted_up="$1"
	TRIGGER_CHANNEL="sql-trigger-channel"	
	NF=`cat $R/db/thing.idx|grep -v "^$" | wc -l`
	req=(setted_up sql TRIGGER_CHANNEL NF)
	ckreq || return $?
	act " Integrate with Redis ..."
	
	[[ -r "$setted_up" ]] || {

	    act "     * creating the function to  ..."
	    print 'DROP FUNCTION IF EXISTS redis_servers_set_v2; 
	           DROP FUNCTION IF EXISTS redis_command_v2;
	           DROP FUNCTION IF EXISTS free_resources;

	           CREATE FUNCTION redis_servers_set_v2 RETURNS int SONAME "lib_mysqludf_redis_v2.so";
	           CREATE FUNCTION redis_command_v2 RETURNS int SONAME "lib_mysqludf_redis_v2.so";
	           CREATE FUNCTION free_resources RETURNS int SONAME "lib_mysqludf_redis_v2.so";'| $sql $db[things]

	    act "     * creating the trigger on update things  ..."

	    print "DROP TRIGGER update_things;" | $sql $db[things]

	    HEADER="DELIMITER ##
		  CREATE TRIGGER update_things 
		  AFTER UPDATE ON found 
		  FOR EACH ROW 
		  BEGIN
		     SET @ret= redis_command_v2(\"publish\",\"$TRIGGER_CHANNEL\", 
		  concat_ws(',','update_things',unix_timestamp(now()),'A','U',$NF"

	    MID=`awk '/^$/ {next} 
{print ",\42"$1"\42,coalesce(OLD."$1",\47_is_null_\47),coalesce(NEW."$1",\47_is_null_\47)"}' $R/db/thing.idx`

	    FOOTER="));
		   END##
		   "

	    func ${HEADER}${MID}${FOOTER}       |cat -n
	    print ${HEADER}${MID}${FOOTER}       | $sql $db[things]


	    act "     * creating trigger on event insert  ..."
	    print "DROP TRIGGER create_things_on_event_insert;" | $sql $db[things]

	    # This trigger insert a things to which is related an "event" (if it's inserted yet).
	    TRIGGER_ON_INSERT_EVENT="DELIMITER ##
                     CREATE TRIGGER create_things_on_event_insert
                     BEFORE INSERT ON event
                     FOR EACH ROW
                     BEGIN
                        INSERT INTO found(macaddr) 
                        SELECT macaddr FROM ( select macaddr ) as tmp 
                        WHERE not exists ( select macaddr from found where macaddr=NEW.macaddr);
                     END##" 

	    func $TRIGGER_ON_INSERT_EVENT
	    print $TRIGGER_ON_INSERT_EVENT | $sql $db[things]
	    
	    touch $setted_up ;
	}
	# TODO: better check of error code if needed	
}



# takes a table description from stdin
# prints "create table" command on stdout
sql_create_table() {
    fn sql_create_table $*
    name="$1"
    req=(name)
    ckreq || return $?

    act "Create table [$name] if not exists ..."
    local cmd="CREATE TABLE IF NOT EXISTS $name ("
    for t in "${(f)$(cat)}"; do
        [[ "$t" = "" ]] && continue
        cmd+="${t},"
    done
    cmd[${#cmd}]=')'
    cmd+=';'

    print - "$cmd"
}

# search for a case insensitive string across all columns
# needs args: .idx, table, string
sql_search() {
    fn sql_search $*
    local idx="$1"
    local table="$2"
    local needle="$3"
    req=(sql db idx table needle)
    freq=($idx)
    ckreq || return $?

    local query="SELECT * from $table where "
    local c=0
    for o in "${(f)$(cat $idx)}"; do
        # skip newlines
        [[ "$o" = "" ]] && continue
        # skip commends
        [[ "${o[1]}" = "#" ]] && continue

        [[ $c = 0 ]] || query+=" or "
        query+="${o[(w)1]} like '%$needle%'"
        c=$(( $c + 1 ))
    done
    print - "$query;" | $sql ${db[things]}
}


sql_map_insert() {
    # TODO:
}

# reads the pipe '|' separated list of results from an SQL query from stdin
# takes as first argument an .idx file (plain text two columns, key and type)
# prints out a string (2 columns formatted for maps) with key and value
sql_idx_parse() {
    fn sql_query $*
    local idx="$1"
    req=(sql db idx)
    freq=($idx)
    ckreq || return $?

    func "parse sql idx: $idx"

    local values="`awk -F '|' '
/^#/ { next }
/^$/ { next }
{ if(NF<1) next;
  for(c=1;c<=NF;c++)
    if($c==\"\") printf \" %\"
    else {
      gsub(/ /,"_",$c)
      printf " " $c
    }
  exit }
'`"
    local c=1

    for o in "${(f)$(cat $idx)}"; do
        # skip newlines
        [[ "$o" = "" ]] && continue
        # skip commends
        [[ "${o[1]}" = "#" ]] && continue
        # TODO: use ${o[(w)2]} for typechecking

        local val="${values[(w)$c]}"
        [[ "$val" = "%" ]] ||
            print - "${o[(w)1]} $val"
        c=$(( $c + 1 ))
    done
}

